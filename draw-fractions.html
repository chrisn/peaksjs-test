<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>waveform-data test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://unpkg.com/waveform-data@2.0.1/dist/waveform-data.js"></script>
    <style>
        body {
            background-color: beige;
        }

        canvas {
            border: 1px solid red;
        }
    </style>
</head>
<body>

    <canvas id="canvas" width="600" height="300"></canvas>

    <script>

        let waveform;
        let length;

        function normalise(num, min, max) {
            return (num - min) / (max - min);
        }

        function scaleX(x) {
            var n = normalise(x, 0, length);
            n = n * canvas.width;
            return n;
        }

        function scaleY(amplitude, height) {
            var range = 256;
            var offset = 128;

            return height - ((amplitude + offset) * height) / range;
        }

        // https://github.com/bbc/peaks.js/blob/c70ccf6618fe3ae5707c6fd7fc74a2396afefaff/src/main/waveform/waveform.mixins.js#L344
        function drawWaveform(context, waveformData, frameOffset, startPixels, endPixels, width, height) {
            
            if (startPixels < frameOffset) {
                startPixels = frameOffset;
            }

            var limit = frameOffset + width;

            if (endPixels > limit) {
                endPixels = limit;
            }

            //var increment = endPixels / (width * 2.5);
            var increment = 1;

            var adapter = waveformData.adapter;
            var x, val;

            context.beginPath();

            for (x = startPixels; x < endPixels; x += increment) {
                val = adapter.at(2 * x);
                context.lineTo(scaleX(x - frameOffset), scaleY(val, height));
                //context.lineTo(x - frameOffset, scaleY(val, height));
            }

            for (x = endPixels - 1; x >= startPixels; x -= increment) {
                val = adapter.at(2 * x + 1);
                context.lineTo(scaleX(x - frameOffset), scaleY(val, height));
                //context.lineTo(x - frameOffset, scaleY(val, height));
            }

            context.closePath();
        }

        function draw() {

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            var frameOffset = 0;
            var startPixels = 0;
            var endPixels = length;
            var width = canvas.width;
            var height = canvas.height;

            drawWaveform(ctx, waveform, frameOffset, startPixels, endPixels, width, height);

            ctx.fill();
        }

        document.addEventListener("DOMContentLoaded", function(event) {
            
            const xhr = new XMLHttpRequest();

            // .dat file generated by audiowaveform program
            xhr.responseType = 'arraybuffer';
            xhr.open("GET", 'vdc_100052359795.0x000018.dat');

            xhr.addEventListener('load', (progressEvent) => {

                const data = new Int16Array(progressEvent.target.response);
                console.log(data.length);

                waveform = WaveformData.create(data.buffer);
                length = waveform.offset_length;
                draw();
            });

            xhr.send();

        });
        
    </script>
</body>
</html>